<?php
 namespace Illuminate\Cache; use Closure; use Exception; use Illuminate\Contracts\Cache\Store; use Illuminate\Support\InteractsWithTime; use Illuminate\Database\ConnectionInterface; class DatabaseStore implements Store { use InteractsWithTime, RetrievesMultipleKeys; protected $connection; protected $table; protected $prefix; public function __construct(ConnectionInterface $connection, $table, $prefix = '') { $this->table = $table; $this->prefix = $prefix; $this->connection = $connection; } public function get($key) { $prefixed = $this->prefix.$key; $cache = $this->table()->where('key', '=', $prefixed)->first(); if (is_null($cache)) { return; } $cache = is_array($cache) ? (object) $cache : $cache; if ($this->currentTime() >= $cache->expiration) { $this->forget($key); return; } return unserialize($cache->value); } public function put($key, $value, $minutes) { $key = $this->prefix.$key; $value = serialize($value); $expiration = $this->getTime() + (int) ($minutes * 60); try { $this->table()->insert(compact('key', 'value', 'expiration')); } catch (Exception $e) { $this->table()->where('key', $key)->update(compact('value', 'expiration')); } } public function increment($key, $value = 1) { return $this->incrementOrDecrement($key, $value, function ($current, $value) { return $current + $value; }); } public function decrement($key, $value = 1) { return $this->incrementOrDecrement($key, $value, function ($current, $value) { return $current - $value; }); } protected function incrementOrDecrement($key, $value, Closure $callback) { return $this->connection->transaction(function () use ($key, $value, $callback) { $prefixed = $this->prefix.$key; $cache = $this->table()->where('key', $prefixed) ->lockForUpdate()->first(); if (is_null($cache)) { return false; } $cache = is_array($cache) ? (object) $cache : $cache; $current = unserialize($cache->value); $new = $callback((int) $current, $value); if (! is_numeric($current)) { return false; } $this->table()->where('key', $prefixed)->update([ 'value' => serialize($new), ]); return $new; }); } protected function getTime() { return $this->currentTime(); } public function forever($key, $value) { $this->put($key, $value, 5256000); } public function forget($key) { $this->table()->where('key', '=', $this->prefix.$key)->delete(); return true; } public function flush() { return (bool) $this->table()->delete(); } protected function table() { return $this->connection->table($this->table); } public function getConnection() { return $this->connection; } public function getPrefix() { return $this->prefix; } } 