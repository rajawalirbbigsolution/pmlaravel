<?php
 class Swift_Signers_DKIMSigner implements Swift_Signers_HeaderSigner { protected $privateKey; protected $domainName; protected $selector; private $passphrase = ''; protected $hashAlgorithm = 'rsa-sha256'; protected $bodyCanon = 'simple'; protected $headerCanon = 'simple'; protected $ignoredHeaders = array('return-path' => true); protected $signerIdentity; protected $bodyLen = 0; protected $maxLen = PHP_INT_MAX; protected $showLen = false; protected $signatureTimestamp = true; protected $signatureExpiration = false; protected $debugHeaders = false; protected $signedHeaders = array(); private $debugHeadersData = ''; private $bodyHash = ''; protected $dkimHeader; private $bodyHashHandler; private $headerHash; private $headerCanonData = ''; private $bodyCanonEmptyCounter = 0; private $bodyCanonIgnoreStart = 2; private $bodyCanonSpace = false; private $bodyCanonLastChar = null; private $bodyCanonLine = ''; private $bound = array(); public function __construct($privateKey, $domainName, $selector, $passphrase = '') { $this->privateKey = $privateKey; $this->domainName = $domainName; $this->signerIdentity = '@'.$domainName; $this->selector = $selector; $this->passphrase = $passphrase; } public function reset() { $this->headerHash = null; $this->signedHeaders = array(); $this->bodyHash = null; $this->bodyHashHandler = null; $this->bodyCanonIgnoreStart = 2; $this->bodyCanonEmptyCounter = 0; $this->bodyCanonLastChar = null; $this->bodyCanonSpace = false; } public function write($bytes) { $this->canonicalizeBody($bytes); foreach ($this->bound as $is) { $is->write($bytes); } } public function commit() { return; } public function bind(Swift_InputByteStream $is) { $this->bound[] = $is; return; } public function unbind(Swift_InputByteStream $is) { foreach ($this->bound as $k => $stream) { if ($stream === $is) { unset($this->bound[$k]); return; } } } public function flushBuffers() { $this->reset(); } public function setHashAlgorithm($hash) { switch ($hash) { case 'rsa-sha1': $this->hashAlgorithm = 'rsa-sha1'; break; case 'rsa-sha256': $this->hashAlgorithm = 'rsa-sha256'; if (!defined('OPENSSL_ALGO_SHA256')) { throw new Swift_SwiftException('Unable to set sha256 as it is not supported by OpenSSL.'); } break; default: throw new Swift_SwiftException('Unable to set the hash algorithm, must be one of rsa-sha1 or rsa-sha256 (%s given).', $hash); } return $this; } public function setBodyCanon($canon) { if ($canon == 'relaxed') { $this->bodyCanon = 'relaxed'; } else { $this->bodyCanon = 'simple'; } return $this; } public function setHeaderCanon($canon) { if ($canon == 'relaxed') { $this->headerCanon = 'relaxed'; } else { $this->headerCanon = 'simple'; } return $this; } public function setSignerIdentity($identity) { $this->signerIdentity = $identity; return $this; } public function setBodySignedLen($len) { if ($len === true) { $this->showLen = true; $this->maxLen = PHP_INT_MAX; } elseif ($len === false) { $this->showLen = false; $this->maxLen = PHP_INT_MAX; } else { $this->showLen = true; $this->maxLen = (int) $len; } return $this; } public function setSignatureTimestamp($time) { $this->signatureTimestamp = $time; return $this; } public function setSignatureExpiration($time) { $this->signatureExpiration = $time; return $this; } public function setDebugHeaders($debug) { $this->debugHeaders = (bool) $debug; return $this; } public function startBody() { switch ($this->hashAlgorithm) { case 'rsa-sha256': $this->bodyHashHandler = hash_init('sha256'); break; case 'rsa-sha1': $this->bodyHashHandler = hash_init('sha1'); break; } $this->bodyCanonLine = ''; } public function endBody() { $this->endOfBody(); } public function getAlteredHeaders() { if ($this->debugHeaders) { return array('DKIM-Signature', 'X-DebugHash'); } else { return array('DKIM-Signature'); } } public function ignoreHeader($header_name) { $this->ignoredHeaders[strtolower($header_name)] = true; return $this; } public function setHeaders(Swift_Mime_SimpleHeaderSet $headers) { $this->headerCanonData = ''; $listHeaders = $headers->listAll(); foreach ($listHeaders as $hName) { if (!isset($this->ignoredHeaders[strtolower($hName)])) { if ($headers->has($hName)) { $tmp = $headers->getAll($hName); foreach ($tmp as $header) { if ($header->getFieldBody() != '') { $this->addHeader($header->toString()); $this->signedHeaders[] = $header->getFieldName(); } } } } } return $this; } public function addSignature(Swift_Mime_SimpleHeaderSet $headers) { $params = array('v' => '1', 'a' => $this->hashAlgorithm, 'bh' => base64_encode($this->bodyHash), 'd' => $this->domainName, 'h' => implode(': ', $this->signedHeaders), 'i' => $this->signerIdentity, 's' => $this->selector); if ($this->bodyCanon != 'simple') { $params['c'] = $this->headerCanon.'/'.$this->bodyCanon; } elseif ($this->headerCanon != 'simple') { $params['c'] = $this->headerCanon; } if ($this->showLen) { $params['l'] = $this->bodyLen; } if ($this->signatureTimestamp === true) { $params['t'] = time(); if ($this->signatureExpiration !== false) { $params['x'] = $params['t'] + $this->signatureExpiration; } } else { if ($this->signatureTimestamp !== false) { $params['t'] = $this->signatureTimestamp; } if ($this->signatureExpiration !== false) { $params['x'] = $this->signatureExpiration; } } if ($this->debugHeaders) { $params['z'] = implode('|', $this->debugHeadersData); } $string = ''; foreach ($params as $k => $v) { $string .= $k.'='.$v.'; '; } $string = trim($string); $headers->addTextHeader('DKIM-Signature', $string); $tmp = $headers->getAll('DKIM-Signature'); $this->dkimHeader = end($tmp); $this->addHeader(trim($this->dkimHeader->toString())."\r\n b=", true); if ($this->debugHeaders) { $headers->addTextHeader('X-DebugHash', base64_encode($this->headerHash)); } $this->dkimHeader->setValue($string.' b='.trim(chunk_split(base64_encode($this->getEncryptedHash()), 73, ' '))); return $this; } protected function addHeader($header, $is_sig = false) { switch ($this->headerCanon) { case 'relaxed': $exploded = explode(':', $header, 2); $name = strtolower(trim($exploded[0])); $value = str_replace("\r\n", '', $exploded[1]); $value = preg_replace("/[ \t][ \t]+/", ' ', $value); $header = $name.':'.trim($value).($is_sig ? '' : "\r\n"); case 'simple': } $this->addToHeaderHash($header); } protected function canonicalizeBody($string) { $len = strlen($string); $canon = ''; $method = ($this->bodyCanon == 'relaxed'); for ($i = 0; $i < $len; ++$i) { if ($this->bodyCanonIgnoreStart > 0) { --$this->bodyCanonIgnoreStart; continue; } switch ($string[$i]) { case "\r": $this->bodyCanonLastChar = "\r"; break; case "\n": if ($this->bodyCanonLastChar == "\r") { if ($method) { $this->bodyCanonSpace = false; } if ($this->bodyCanonLine == '') { ++$this->bodyCanonEmptyCounter; } else { $this->bodyCanonLine = ''; $canon .= "\r\n"; } } else { } break; case ' ': case "\t": if ($method) { $this->bodyCanonSpace = true; break; } default: if ($this->bodyCanonEmptyCounter > 0) { $canon .= str_repeat("\r\n", $this->bodyCanonEmptyCounter); $this->bodyCanonEmptyCounter = 0; } if ($this->bodyCanonSpace) { $this->bodyCanonLine .= ' '; $canon .= ' '; $this->bodyCanonSpace = false; } $this->bodyCanonLine .= $string[$i]; $canon .= $string[$i]; } } $this->addToBodyHash($canon); } protected function endOfBody() { if (strlen($this->bodyCanonLine) > 0) { $this->addToBodyHash("\r\n"); } $this->bodyHash = hash_final($this->bodyHashHandler, true); } private function addToBodyHash($string) { $len = strlen($string); if ($len > ($new_len = ($this->maxLen - $this->bodyLen))) { $string = substr($string, 0, $new_len); $len = $new_len; } hash_update($this->bodyHashHandler, $string); $this->bodyLen += $len; } private function addToHeaderHash($header) { if ($this->debugHeaders) { $this->debugHeadersData[] = trim($header); } $this->headerCanonData .= $header; } private function getEncryptedHash() { $signature = ''; switch ($this->hashAlgorithm) { case 'rsa-sha1': $algorithm = OPENSSL_ALGO_SHA1; break; case 'rsa-sha256': $algorithm = OPENSSL_ALGO_SHA256; break; } $pkeyId = openssl_get_privatekey($this->privateKey, $this->passphrase); if (!$pkeyId) { throw new Swift_SwiftException('Unable to load DKIM Private Key ['.openssl_error_string().']'); } if (openssl_sign($this->headerCanonData, $signature, $pkeyId, $algorithm)) { return $signature; } throw new Swift_SwiftException('Unable to sign DKIM Hash ['.openssl_error_string().']'); } } 