<?php
 namespace Symfony\Component\EventDispatcher\Tests\DependencyInjection; use PHPUnit\Framework\TestCase; use Symfony\Component\DependencyInjection\Argument\ServiceClosureArgument; use Symfony\Component\DependencyInjection\ContainerBuilder; use Symfony\Component\DependencyInjection\Reference; use Symfony\Component\EventDispatcher\DependencyInjection\RegisterListenersPass; class RegisterListenersPassTest extends TestCase { public function testEventSubscriberWithoutInterface() { $builder = new ContainerBuilder(); $builder->register('event_dispatcher'); $builder->register('my_event_subscriber', 'stdClass') ->addTag('kernel.event_subscriber'); $registerListenersPass = new RegisterListenersPass(); $registerListenersPass->process($builder); } public function testValidEventSubscriber() { $services = array( 'my_event_subscriber' => array(0 => array()), ); $builder = new ContainerBuilder(); $eventDispatcherDefinition = $builder->register('event_dispatcher'); $builder->register('my_event_subscriber', 'Symfony\Component\EventDispatcher\Tests\DependencyInjection\SubscriberService') ->addTag('kernel.event_subscriber'); $registerListenersPass = new RegisterListenersPass(); $registerListenersPass->process($builder); $expectedCalls = array( array( 'addListener', array( 'event', array(new ServiceClosureArgument(new Reference('my_event_subscriber')), 'onEvent'), 0, ), ), ); $this->assertEquals($expectedCalls, $eventDispatcherDefinition->getMethodCalls()); } public function testAbstractEventListener() { $container = new ContainerBuilder(); $container->register('foo', 'stdClass')->setAbstract(true)->addTag('kernel.event_listener', array()); $container->register('event_dispatcher', 'stdClass'); $registerListenersPass = new RegisterListenersPass(); $registerListenersPass->process($container); } public function testAbstractEventSubscriber() { $container = new ContainerBuilder(); $container->register('foo', 'stdClass')->setAbstract(true)->addTag('kernel.event_subscriber', array()); $container->register('event_dispatcher', 'stdClass'); $registerListenersPass = new RegisterListenersPass(); $registerListenersPass->process($container); } public function testEventSubscriberResolvableClassName() { $container = new ContainerBuilder(); $container->setParameter('subscriber.class', 'Symfony\Component\EventDispatcher\Tests\DependencyInjection\SubscriberService'); $container->register('foo', '%subscriber.class%')->addTag('kernel.event_subscriber', array()); $container->register('event_dispatcher', 'stdClass'); $registerListenersPass = new RegisterListenersPass(); $registerListenersPass->process($container); $definition = $container->getDefinition('event_dispatcher'); $expectedCalls = array( array( 'addListener', array( 'event', array(new ServiceClosureArgument(new Reference('foo')), 'onEvent'), 0, ), ), ); $this->assertEquals($expectedCalls, $definition->getMethodCalls()); } public function testHotPathEvents() { $container = new ContainerBuilder(); $container->register('foo', SubscriberService::class)->addTag('kernel.event_subscriber', array()); $container->register('event_dispatcher', 'stdClass'); (new RegisterListenersPass())->setHotPathEvents(array('event'))->process($container); $this->assertTrue($container->getDefinition('foo')->hasTag('container.hot_path')); } public function testEventSubscriberUnresolvableClassName() { $container = new ContainerBuilder(); $container->register('foo', '%subscriber.class%')->addTag('kernel.event_subscriber', array()); $container->register('event_dispatcher', 'stdClass'); $registerListenersPass = new RegisterListenersPass(); $registerListenersPass->process($container); } } class SubscriberService implements \Symfony\Component\EventDispatcher\EventSubscriberInterface { public static function getSubscribedEvents() { return array( 'event' => 'onEvent', ); } } 